/*
Copyright 2022 The KubeVela Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package process

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"unicode"

	"github.com/pkg/errors"
	"k8s.io/klog/v2"

	"github.com/kubevela/workflow/pkg/cue/model"
)

// Context defines Rendering Context Interface
type Context interface {
	SetBase(base model.Instance) error
	AppendAuxiliaries(auxiliaries ...Auxiliary) error
	Output() (model.Instance, []Auxiliary)
	BaseContextFile() (string, error)
	BaseContextLabels() map[string]string
	SetParameters(params map[string]interface{})
	PushData(key string, data interface{})
	RemoveData(key string)
	GetData(key string) interface{}
	GetCtx() context.Context
	SetCtx(context.Context)
}

// Auxiliary are objects rendered by definition template.
// the format for auxiliary resource is always: `outputs.<resourceName>`, it can be auxiliary workload or trait
type Auxiliary struct {
	Ins model.Instance
	// Type will be used to mark definition label for OAM runtime to get the CRD
	// It's now required for trait and main workload object. Extra workload CR object will not have the type.
	Type string

	// Workload or trait with multiple `outputs` will have a name, if name is empty, than it's the main of this type.
	Name string
}

type templateContext struct {
	base        model.Instance
	auxiliaries []Auxiliary

	baseHooks      []BaseHook
	auxiliaryHooks []AuxiliaryHook

	customData map[string]interface{}
	data       map[string]interface{}

	ctx context.Context
}

// RequiredSecrets is used to store all secret names which are generated by cloud resource components and required by current component
type RequiredSecrets struct {
	Namespace   string
	Name        string
	ContextName string
	Data        map[string]interface{}
}

// ContextData is the core data of process context
type ContextData struct {
	Name           string
	Namespace      string
	StepName       string
	WorkflowName   string
	PublishVersion string

	Ctx            context.Context
	CustomData     map[string]interface{}
	Data           map[string]interface{}
	BaseHooks      []BaseHook
	AuxiliaryHooks []AuxiliaryHook
}

// NewContext create render templateContext
func NewContext(data ContextData) Context {
	ctx := &templateContext{
		ctx:            data.Ctx,
		customData:     data.CustomData,
		data:           data.Data,
		baseHooks:      data.BaseHooks,
		auxiliaryHooks: data.AuxiliaryHooks,
		auxiliaries:    []Auxiliary{},
	}
	ctx.PushData(model.ContextName, data.Name)
	ctx.PushData(model.ContextNamespace, data.Namespace)
	ctx.PushData(model.ContextWorkflowName, data.WorkflowName)
	ctx.PushData(model.ContextPublishVersion, data.PublishVersion)
	return ctx
}

// SetParameters sets templateContext parameters
func (ctx *templateContext) SetParameters(params map[string]interface{}) {
	ctx.PushData(model.ParameterFieldName, params)
}

// SetBase set templateContext base model
func (ctx *templateContext) SetBase(base model.Instance) error {
	for _, hook := range ctx.baseHooks {
		if err := hook.Exec(ctx, base); err != nil {
			return errors.Wrap(err, "cannot set base into context")
		}
	}
	ctx.base = base
	return nil
}

// AppendAuxiliaries add Assist model to templateContext
func (ctx *templateContext) AppendAuxiliaries(auxiliaries ...Auxiliary) error {
	for _, hook := range ctx.auxiliaryHooks {
		if err := hook.Exec(ctx, auxiliaries); err != nil {
			return errors.Wrap(err, "cannot append auxiliaries into context")
		}
	}
	ctx.auxiliaries = append(ctx.auxiliaries, auxiliaries...)
	return nil
}

// BaseContextFile return cue format string of templateContext
func (ctx *templateContext) BaseContextFile() (string, error) {
	var buff string

	if ctx.base != nil {
		base, err := ctx.base.Value().MarshalJSON()
		if err != nil {
			return "", err
		}
		var b any
		if err := json.Unmarshal(base, &b); err != nil {
			return "", err
		}
		ctx.PushData(model.OutputFieldName, b)
	}

	if len(ctx.auxiliaries) > 0 {
		auxLines := make(map[string]any)
		for _, auxiliary := range ctx.auxiliaries {
			aux, err := auxiliary.Ins.Value().MarshalJSON()
			if err != nil {
				return "", err
			}
			var a any
			if err := json.Unmarshal(aux, &a); err != nil {
				return "", err
			}
			auxLines[auxiliary.Name] = a
		}
		if len(auxLines) > 0 {
			ctx.PushData(model.OutputsFieldName, auxLines)
		}
	}

	for k, v := range ctx.customData {
		if exist := ctx.GetData(k); exist != nil && !reflect.DeepEqual(exist, v) {
			klog.Warningf("Built-in value [%s: %s] in context will be overridden", k, exist)
		}
		ctx.PushData(k, v)
	}

	if ctx.data != nil {
		d, err := json.Marshal(ctx.data)
		if err != nil {
			return "", err
		}
		buff += fmt.Sprintf("\n %s", structMarshal(string(d)))
	}

	return fmt.Sprintf("context: %s", structMarshal(buff)), nil
}

func (ctx *templateContext) BaseContextLabels() map[string]string {
	return map[string]string{
		model.ContextName: fmt.Sprint(ctx.GetData(model.ContextName)),
	}
}

// Output return model and auxiliaries of templateContext
func (ctx *templateContext) Output() (model.Instance, []Auxiliary) {
	return ctx.base, ctx.auxiliaries
}

// InsertSecrets will add cloud resource secret stuff to context
func (ctx *templateContext) InsertSecrets(outputSecretName string, requiredSecrets []RequiredSecrets) {
	if outputSecretName != "" {
		ctx.PushData(model.OutputSecretName, outputSecretName)
	}
	for _, s := range requiredSecrets {
		ctx.PushData(s.ContextName, s.Data)
	}
}

// PushData appends arbitrary extension data to context
func (ctx *templateContext) PushData(key string, data interface{}) {
	if ctx.data == nil {
		ctx.data = map[string]interface{}{key: data}
		return
	}
	ctx.data[key] = data
}

func (ctx *templateContext) RemoveData(key string) {
	delete(ctx.data, key)
}

// GetData get data from context
func (ctx *templateContext) GetData(key string) interface{} {
	return ctx.data[key]
}

func (ctx *templateContext) GetCtx() context.Context {
	if ctx.ctx != nil {
		return ctx.ctx
	}
	return context.TODO()
}

func (ctx *templateContext) SetCtx(newContext context.Context) {
	ctx.ctx = newContext
}

func structMarshal(v string) string {
	skip := false
	v = strings.TrimFunc(v, func(r rune) bool {
		if !skip {
			if unicode.IsSpace(r) {
				return true
			}
			skip = true

		}
		return false
	})

	if strings.HasPrefix(v, "{") {
		return v
	}
	return fmt.Sprintf("{%s}", v)
}
